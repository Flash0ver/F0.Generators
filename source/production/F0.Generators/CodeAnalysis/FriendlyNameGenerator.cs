using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using F0.CodeDom.Compiler;
using F0.Extensions;
using F0.Text;

namespace F0.CodeAnalysis;

[Generator(LanguageNames.CSharp)]
internal sealed partial class FriendlyNameGenerator : IIncrementalGenerator
{
	private const string TypeName = "Friendly";
	private const string HintName = "Friendly.g.cs";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValuesProvider<TypeSyntax> nameOfSyntaxProvider = context.SyntaxProvider
			.CreateSyntaxProvider(static (syntaxNode, cancellationToken) => SyntaxProviderPredicate(syntaxNode, NameOf_MethodName), SyntaxProviderTransform);
		IncrementalValuesProvider<TypeSyntax> fullNameOfSyntaxProvider = context.SyntaxProvider
			.CreateSyntaxProvider(static (syntaxNode, cancellationToken) => SyntaxProviderPredicate(syntaxNode, FullNameOf_MethodName), SyntaxProviderTransform);

		IncrementalValueProvider<(ImmutableArray<TypeSyntax> NameOfInvocations, ImmutableArray<TypeSyntax> FullNameOfInvocations)> combined =
			nameOfSyntaxProvider.Collect().Combine(fullNameOfSyntaxProvider.Collect());

		IncrementalValueProvider<((ImmutableArray<TypeSyntax> NameOfInvocations, ImmutableArray<TypeSyntax> FullNameOfInvocations) Left, Compilation Compilation)> withCompilation =
			combined.Combine(context.CompilationProvider);

		IncrementalValueProvider<(((ImmutableArray<TypeSyntax> NameOfInvocations, ImmutableArray<TypeSyntax> FullNameOfInvocations) Other, Compilation Compilation) Other, ParseOptions ParseOptions)> source = withCompilation
			.Combine(context.ParseOptionsProvider);

		context.RegisterSourceOutput(source, Execute);
	}

	private void Execute(SourceProductionContext context, (((ImmutableArray<TypeSyntax> NameOfInvocations, ImmutableArray<TypeSyntax> FullNameOfInvocations) Other, Compilation Compilation) Other, ParseOptions ParseOptions) source)
	{
		Debug.Assert(source.ParseOptions.IsCSharp());

		IReadOnlyCollection<ITypeSymbol> nameOf = GetDistinct_NameOf_Invocations(source.Other.Other.NameOfInvocations, source.Other.Compilation, context.CancellationToken);
		IReadOnlyCollection<ITypeSymbol> fullNameOf = GetDistinct_FullNameOf_Invocations(source.Other.Other.FullNameOfInvocations, source.Other.Compilation, context.CancellationToken);

		string text = GenerateSourceCode(source.ParseOptions, nameOf, fullNameOf);

		var sourceText = SourceText.From(text, Encodings.Utf8NoBom);
		context.AddSource(HintName, sourceText);
	}

	private static string GenerateSourceCode(ParseOptions parseOptions, IReadOnlyCollection<ITypeSymbol> nameOf, IReadOnlyCollection<ITypeSymbol> fullNameOf)
	{
		using StringWriter writer = new(CultureInfo.InvariantCulture);
		using IndentedTextWriter source = new(writer, Trivia.Tab);

		LanguageVersion languageVersion = parseOptions.GetCSharpLanguageVersion();
		LanguageFeatures languageFeatures = new(languageVersion);

		Write_FileHeader_To(source);
		Write_NullablePreprocessorDirective_To(source, languageFeatures);

		source.WriteLine("namespace F0.Generated");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;

		source.WriteLine($"internal static class {TypeName}");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;

		Write_NameOf_FieldDeclaration_To(source, nameOf);
		Write_FullNameOf_FieldDeclaration_To(source, fullNameOf);

		if (nameOf.Count > 0 || fullNameOf.Count > 0)
		{
			source.WriteLineNoTabs();
		}

		Write_NameOf_MethodDeclaration_To(source, nameOf);
		source.WriteLineNoTabs();
		Write_FullNameOf_MethodDeclaration_To(source, fullNameOf);

		Write_CreateNameOf_MethodDeclaration_To(source, nameOf, languageFeatures);
		Write_CreateFullNameOf_MethodDeclaration_To(source, fullNameOf, languageFeatures);

		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		Debug.Assert(source.Indent == 0, $"Expected {nameof(source.Indent)}: 0; Actual {nameof(source.Indent)}: {source.Indent}");
		return writer.ToString();
	}

	private static void Write_FileHeader_To(TextWriter writer)
	{
		writer.WriteLine("// <auto-generated/>");
		writer.WriteLine();
	}

	private static void Write_NullablePreprocessorDirective_To(TextWriter writer, LanguageFeatures features)
	{
		if (features.HasNullableReferenceTypes)
		{
			writer.WriteLine("#nullable enable");
			writer.WriteLine();
		}
	}

	private sealed class LanguageFeatures
	{
		public LanguageFeatures(LanguageVersion version)
			=> LanguageVersion = version;

		public LanguageVersion LanguageVersion { get; }

		public bool HasNullableReferenceTypes => LanguageVersion >= LanguageVersion.CSharp8;
		public bool HasTargetTypedObjectCreation => LanguageVersion >= LanguageVersion.CSharp9;
	}
}
