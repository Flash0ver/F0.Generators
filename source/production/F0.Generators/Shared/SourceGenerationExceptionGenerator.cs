using System.CodeDom.Compiler;
using System.Diagnostics;
using System.Globalization;
using F0.CodeDom.Compiler;
using F0.Extensions;
using F0.Text;

namespace F0.Shared;

[Generator]
internal sealed partial class SourceGenerationExceptionGenerator : ISourceGenerator
{
	internal const string TypeName = "SourceGenerationException";
	private const string HintName = "SourceGenerationException.g.cs";

	public void Initialize(GeneratorInitializationContext context)
		=> context.RegisterForSyntaxNotifications(SourceGenerationExceptionReceiver.Create);

	public void Execute(GeneratorExecutionContext context)
	{
		Debug.Assert(context.SyntaxReceiver is not null);

		if (context.ParseOptions.IsCSharp() && context.SyntaxReceiver is SourceGenerationExceptionReceiver receiver)
		{
			string source = GenerateSourceCode(context.ParseOptions);

			var sourceText = SourceText.From(source, Encodings.Utf8NoBom);
			context.AddSource(HintName, sourceText);

			ReportDiagnostics(receiver.References, context);
		}
	}

	private static string GenerateSourceCode(ParseOptions parseOptions)
	{
		using StringWriter writer = new(CultureInfo.InvariantCulture);
		using IndentedTextWriter source = new(writer, Trivia.Tab);

		LanguageVersion languageVersion = parseOptions.GetCSharpLanguageVersion();
		LanguageFeatures languageFeatures = new(languageVersion);

		source.WriteLine("// <auto-generated/>");
		source.WriteLine();

		if (languageFeatures.HasNullableReferenceTypes)
		{
			source.WriteLine("#nullable enable");
			source.WriteLine();
		}

		source.WriteLine("namespace F0.Generated");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;

		if (languageFeatures.HasNamespaceAliasQualifier)
		{
			source.WriteLine($"internal sealed class {TypeName} : global::System.Exception");
		}
		else
		{
			source.WriteLine($"internal sealed class {TypeName} : System.Exception");
		}
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;

		source.WriteLine($@"private const string helpLink = ""{Uris.Repository}"";");

		source.WriteLineNoTabs();

		source.WriteLine($"public {TypeName}()");
		source.WriteLineIndented(": base(CreateNotGeneratedMessage())");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;
		source.WriteLine("HelpLink = helpLink;");
		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.WriteLineNoTabs();

		source.WriteLine($"public {TypeName}(string message)");
		source.WriteLineIndented(": base(message)");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;
		source.WriteLine("HelpLink = helpLink;");
		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.WriteLineNoTabs();

		if (languageFeatures.HasNamespaceAliasQualifier)
		{
			source.WriteLine($"public {TypeName}(string message, global::System.Exception innerException)");
		}
		else
		{
			source.WriteLine($"public {TypeName}(string message, System.Exception innerException)");
		}
		source.WriteLineIndented(": base(message, innerException)");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;
		source.WriteLine("HelpLink = helpLink;");
		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.WriteLineNoTabs();

		source.WriteLine("private static string CreateNotGeneratedMessage()");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;
		source.WriteLine($@"const string uri = ""{Uris.Issues}"";");
		source.WriteLineNoTabs();
		source.WriteLine(@"return ""The method or operation was not generated correctly.""");
		source.Indent++;
		source.WriteLine(@"+ "" Please leave a comment on a related issue, or create a new issue at """);
		source.WriteLine(@"+ ""'"" + uri + ""'""");
		source.WriteLine(@"+ "". Thank you!"";");
		source.Indent--;
		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		return writer.ToString();
	}

	private static void ReportDiagnostics(IReadOnlyCollection<IdentifierNameSyntax> references, GeneratorExecutionContext context)
	{
		foreach (IdentifierNameSyntax reference in references)
		{
			SyntaxNode node = reference;

			if (node.Parent is NullableTypeSyntax nullable)
			{
				node = nullable;
			}

			if (reference.Parent is QualifiedNameSyntax name)
			{
				node = name;
			}

			Location location = node.GetLocation();

			string expression;
			if (node.Parent is ObjectCreationExpressionSyntax creation && creation.Parent is ThrowStatementSyntax @throw)
			{
				expression = @throw.ToString();
			}
			else
			{
				Debug.Assert(node.Parent is not null);
				expression = node.Parent.ToString();
			}

			var diagnostic = Diagnostic.Create(AvoidUsage, location, expression);
			context.ReportDiagnostic(diagnostic);
		}
	}

	private sealed class LanguageFeatures
	{
		private readonly LanguageVersion languageVersion;

		public LanguageFeatures(LanguageVersion version)
			=> languageVersion = version;

		public bool HasNamespaceAliasQualifier => languageVersion >= LanguageVersion.CSharp2;
		public bool HasNullableReferenceTypes => languageVersion >= LanguageVersion.CSharp8;
	}
}
