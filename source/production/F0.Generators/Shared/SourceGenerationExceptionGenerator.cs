using System.CodeDom.Compiler;
using System.Collections.Immutable;
using System.Diagnostics;
using System.Globalization;
using F0.CodeDom.Compiler;
using F0.Extensions;
using F0.Text;

namespace F0.Shared;

[Generator(LanguageNames.CSharp)]
internal sealed partial class SourceGenerationExceptionGenerator : IIncrementalGenerator
{
	private const string TypeName = "SourceGenerationException";
	private const string HintName = "SourceGenerationException.g.cs";

	public void Initialize(IncrementalGeneratorInitializationContext context)
	{
		IncrementalValuesProvider<IdentifierNameSyntax> syntaxProvider = context.SyntaxProvider
			.CreateSyntaxProvider(SyntaxProviderPredicate, SyntaxProviderTransform);

		IncrementalValueProvider<(ImmutableArray<IdentifierNameSyntax> References, ParseOptions ParseOptions)> source =
			syntaxProvider.Collect().Combine(context.ParseOptionsProvider);

		context.RegisterSourceOutput(source, Execute);
	}

	private static void Execute(SourceProductionContext context, (ImmutableArray<IdentifierNameSyntax> References, ParseOptions ParseOptions) source)
	{
		Debug.Assert(source.ParseOptions.IsCSharp());

		LanguageVersion languageVersion = source.ParseOptions.GetCSharpLanguageVersion();
		LanguageFeatures languageFeatures = new(languageVersion);

		string text = GenerateSourceCode(languageFeatures);

		var sourceText = SourceText.From(text, Encodings.Utf8NoBom);
		context.AddSource(HintName, sourceText);

		ReportDiagnostics(source.References, context);
	}

	private static string GenerateSourceCode(LanguageFeatures features)
	{
		using StringWriter writer = new(CultureInfo.InvariantCulture);
		using IndentedTextWriter source = new(writer, Trivia.Tab);

		source.WriteLine("// <auto-generated/>");
		source.WriteLine();

		if (features.HasNullableReferenceTypes)
		{
			source.WriteLine("#nullable enable");
			source.WriteLine();
		}

		source.WriteLine("namespace F0.Generated");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;

		source.WriteLine($"internal sealed class {TypeName} : global::System.Exception");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;

		source.WriteLine($@"private const string helpLink = ""{Uris.Repository}"";");

		source.WriteLineNoTabs();

		source.WriteLine($"public {TypeName}()");
		source.WriteLineIndented(": base(CreateNotGeneratedMessage())");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;
		source.WriteLine("HelpLink = helpLink;");
		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.WriteLineNoTabs();

		source.WriteLine($"public {TypeName}(string message)");
		source.WriteLineIndented(": base(message)");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;
		source.WriteLine("HelpLink = helpLink;");
		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.WriteLineNoTabs();

		source.WriteLine($"public {TypeName}(string message, global::System.Exception innerException)");
		source.WriteLineIndented(": base(message, innerException)");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;
		source.WriteLine("HelpLink = helpLink;");
		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.WriteLineNoTabs();

		source.WriteLine("private static string CreateNotGeneratedMessage()");
		source.WriteLine(Tokens.OpenBrace);
		source.Indent++;
		source.WriteLine($@"const string uri = ""{Uris.Issues}"";");
		source.WriteLineNoTabs();
		source.WriteLine(@"return ""The method or operation was not generated correctly.""");
		source.Indent++;
		source.WriteLine(@"+ "" Please leave a comment on a related issue, or create a new issue at """);
		source.WriteLine(@"+ ""'"" + uri + ""'""");
		source.WriteLine(@"+ "". Thank you!"";");
		source.Indent--;
		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		source.Indent--;
		source.WriteLine(Tokens.CloseBrace);

		Debug.Assert(source.Indent == 0, $"Expected {nameof(source.Indent)}: 0; Actual {nameof(source.Indent)}: {source.Indent}");
		return writer.ToString();
	}

	private static void ReportDiagnostics(ImmutableArray<IdentifierNameSyntax> references, SourceProductionContext context)
	{
		foreach (IdentifierNameSyntax reference in references)
		{
			SyntaxNode node = reference;

			if (node.Parent is NullableTypeSyntax nullable)
			{
				node = nullable;
			}

			if (reference.Parent is QualifiedNameSyntax name)
			{
				node = name;
			}

			Location location = node.GetLocation();

			string expression;
			if (node.Parent is ObjectCreationExpressionSyntax creation && creation.Parent is ThrowStatementSyntax @throw)
			{
				expression = @throw.ToString();
			}
			else
			{
				Debug.Assert(node.Parent is not null);
				expression = node.Parent.ToString();
			}

			var diagnostic = Diagnostic.Create(AvoidUsage, location, expression);
			context.ReportDiagnostic(diagnostic);
		}
	}

	private sealed class LanguageFeatures
	{
		private readonly LanguageVersion languageVersion;

		public LanguageFeatures(LanguageVersion version)
			=> languageVersion = version;

		public bool HasNullableReferenceTypes => languageVersion >= LanguageVersion.CSharp8;
	}
}
